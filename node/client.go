package node

import (
	"fmt"
	"io"
	"log"
	"net"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/websocket"
)

// Bridge represents an active connection to a service
type Bridge struct {
	ID       string
	Service  Service
	Conn     net.Conn
	StopChan chan struct{}
}

// NodeClient manages the connection to the relay server
type NodeClient struct {
	relayAddr    string
	nodeID       string // Generated by node, confirmed by relay after auth
	dashboardURL string // Dashboard URL from relay
	services     []Service
	conn         MessageTransport // Supports both Conn (TCP) and WebSocketConn (WebSocket)
	bridges      map[string]*Bridge
	bridgeMu     sync.RWMutex
	shutdown     chan struct{}
	closed       bool
	closeMu      sync.Mutex

	// Authorization fields
	token  string  // Authorization token
	config *Config // Config for saving token when received

	// Callback when connection is ready (nodeID and dashboardURL received)
	OnConnectionReady func(nodeID, dashboardURL string)

	// For testing: track received data per bridge
	DataReceived map[string][]byte
	dataMu       sync.Mutex
}

// NewNodeClient creates a new node client
func NewNodeClient(relayAddr string, services []Service, nodeID, token string) *NodeClient {
	return &NodeClient{
		relayAddr:    relayAddr,
		nodeID:       nodeID,
		token:        token,
		services:     services,
		bridges:      make(map[string]*Bridge),
		shutdown:     make(chan struct{}),
		DataReceived: make(map[string][]byte),
	}
}

// NodeID returns the relay-assigned node ID
func (nc *NodeClient) NodeID() string {
	return nc.nodeID
}

// DashboardURL returns the dashboard URL
func (nc *NodeClient) DashboardURL() string {
	return nc.dashboardURL
}

// Run connects to the relay and handles messages
func (nc *NodeClient) Run(config *Config) error {
	nc.config = config

	// Validate relay address format
	if err := validateRelayAddr(nc.relayAddr); err != nil {
		return err
	}

	log.Printf("[Node] Connecting to relay at %s", nc.relayAddr)

	// Connect to relay via WebSocket
	dialer := websocket.Dialer{
		HandshakeTimeout: 10 * time.Second,
	}

	wsConn, _, err := dialer.Dial(nc.relayAddr, nil)
	if err != nil {
		return fmt.Errorf("dial relay %s: %w", nc.relayAddr, err)
	}

	// Wrap in transport adapter
	nc.conn = NewWebSocketConn(wsConn)

	// Set up ping/pong handlers for keepalive
	if wsTransport, ok := nc.conn.(*WebSocketConn); ok {
		wsTransport.SetPongHandler(func(appData string) error {
			return wsTransport.SetReadDeadline(time.Now().Add(60 * time.Second))
		})

		// Start ping sender
		go nc.pingLoop(wsTransport)
	}

	// Ensure we have a token (blocks until we do)
	if err := nc.ensureToken(); err != nil {
		return err
	}

	// Send REGISTER with token
	if err := nc.sendRegister(); err != nil {
		return fmt.Errorf("send register: %w", err)
	}

	// Send ANNOUNCE with services
	if err := nc.sendAnnounce(); err != nil {
		return fmt.Errorf("send announce: %w", err)
	}

	// Message loop
	return nc.messageLoop()
}

// ensureToken blocks until we have an authorization token
func (nc *NodeClient) ensureToken() error {
	if nc.token != "" {
		return nil // Already have token
	}

	log.Printf("[Node] No token found, requesting authorization...")
	if err := nc.sendReqAuthorizationURL(); err != nil {
		return fmt.Errorf("send req authorization URL: %w", err)
	}

	// Wait for AUTH_TOKEN message
	for {
		select {
		case <-nc.shutdown:
			return nil
		default:
		}

		msg, err := nc.conn.ReadMessage()
		if err != nil {
			return fmt.Errorf("read message: %w", err)
		}

		// Handle message through normal flow
		if err := nc.handleMessage(msg); err != nil {
			log.Printf("[Node] Error handling message: %v", err)
		}

		// Check if we received the token
		if nc.token != "" {
			return nil
		}
	}
}

// sendRegister sends a REGISTER message with authorization token
func (nc *NodeClient) sendRegister() error {
	msgID := uuid.New().String()
	msg := &Message{
		MsgID: msgID,
		Control: &ControlMsg{
			Type:  MsgTypeRegister,
			Token: nc.token,
		},
	}
	if err := nc.conn.WriteMessage(msg); err != nil {
		return fmt.Errorf("write register: %w", err)
	}
	return nil
}

// sendReqAuthorizationURL sends a REQ_AUTHORIZATION_URL message to the relay
func (nc *NodeClient) sendReqAuthorizationURL() error {
	msgID := uuid.New().String()
	msg := NewReqAuthorizationURLMsg(msgID, nc.nodeID)
	if err := nc.conn.WriteMessage(msg); err != nil {
		return fmt.Errorf("write req authorization URL: %w", err)
	}
	return nil
}

// sendAnnounce sends an ANNOUNCE message with available services
func (nc *NodeClient) sendAnnounce() error {
	msgID := uuid.New().String()
	msg := NewAnnounceMsg(msgID, nc.services)
	if err := nc.conn.WriteMessage(msg); err != nil {
		return fmt.Errorf("write announce: %w", err)
	}
	log.Printf("[Node] Sent ANNOUNCE with %d services", len(nc.services))
	return nil
}

// messageLoop handles incoming messages from the relay
func (nc *NodeClient) messageLoop() error {
	for {
		select {
		case <-nc.shutdown:
			return nil
		default:
		}

		msg, err := nc.conn.ReadMessage()
		if err != nil {
			return fmt.Errorf("read message: %w", err)
		}

		if err := nc.handleMessage(msg); err != nil {
			return err
		}
	}
}

// handleMessage dispatches a message to the appropriate handler
func (nc *NodeClient) handleMessage(msg *Message) error {
	if msg.IsControl() {
		return nc.handleControl(msg)
	}
	if msg.IsData() {
		return nc.handleData(msg)
	}
	return fmt.Errorf("unknown message type")
}

// handleControl handles control messages from the relay
func (nc *NodeClient) handleControl(msg *Message) error {
	ctrl := msg.Control

	switch ctrl.Type {
	case MsgTypeAck:
		return nil

	case MsgTypeConnectionReady:
		return nc.handleConnectionReady(ctrl.NodeID, ctrl.DashboardURL)

	case MsgTypeResAuthorizationURL:
		return nc.handleResAuthorizationURL(ctrl.AuthURL)

	case MsgTypeAuthToken:
		nc.token = ctrl.Token
		log.Printf("[Node] Authorization complete! Token received.")

		// Save token to config
		if nc.config != nil {
			nc.config.Token = ctrl.Token
			if err := SaveConfig(nc.config); err != nil {
				log.Printf("[Node] Failed to save token: %v", err)
			} else {
				log.Printf("[Node] Token saved. Node is now running.")
			}
		}

		return nil

	case MsgTypeRegisterError:
		return nc.handleRegisterError(ctrl.ErrorCode, ctrl.ErrorMsg)

	case MsgTypeOpenBridge:
		return nc.handleOpenBridge(msg)

	case MsgTypeCloseBridge:
		return nc.handleCloseBridge(ctrl.BridgeID)

	default:
		return fmt.Errorf("unknown control type: %s", ctrl.Type)
	}
}

// handleConnectionReady handles CONNECTION_READY messages from the relay
func (nc *NodeClient) handleConnectionReady(nodeID, dashboardURL string) error {
	nc.nodeID = nodeID
	nc.dashboardURL = dashboardURL
	log.Printf("[Node] Connection ready: nodeID=%s, dashboard=%s", nodeID, dashboardURL)

	if nc.OnConnectionReady != nil {
		nc.OnConnectionReady(nodeID, dashboardURL)
	}

	return nil
}

// handleResAuthorizationURL handles RES_AUTHORIZATION_URL messages from the relay
func (nc *NodeClient) handleResAuthorizationURL(authURL string) error {
	log.Printf("[Node] Authorization required!")
	log.Printf("[Node] Open this URL in your browser to authorize this node:")
	log.Printf("[Node] %s", authURL)

	return nil
}

// handleRegisterError handles REGISTER_ERROR messages from the relay
func (nc *NodeClient) handleRegisterError(errorCode, errorMsg string) error {
	// Map error codes to user-friendly messages
	var userMsg string
	switch errorCode {
	case "invalid_token":
		userMsg = "Invalid authorization token. Please run 'unblink logout' and re-authorize."
	case "unauthorized":
		userMsg = "Node not yet authorized. Please complete the authorization flow."
	case "missing_token":
		userMsg = "No authorization token found. Please run 'unblink login' to authorize."
	case "not_registered":
		userMsg = "Node registration incomplete. Please restart the node."
	default:
		userMsg = fmt.Sprintf("Registration failed: %s", errorMsg)
	}

	return fmt.Errorf("Registration error: %s", userMsg)
}

// handleOpenBridge handles OPEN_BRIDGE requests from the relay
func (nc *NodeClient) handleOpenBridge(msg *Message) error {
	ctrl := msg.Control
	bridgeID := ctrl.BridgeID
	service := ctrl.Service

	if service == nil {
		return fmt.Errorf("open_bridge: missing service")
	}

	log.Printf("[Node] Received OPEN_BRIDGE request: %s -> %s (%s:%d)", bridgeID, service.Name, service.Addr, service.Port)

	// Connect to the service
	serviceAddr := net.JoinHostPort(service.Addr, fmt.Sprintf("%d", service.Port))
	svcConn, err := net.Dial("tcp", serviceAddr)
	if err != nil {
		// Send ACK to relay so it knows bridge failed, then continue
		// Don't return error - other services should keep running
		nc.sendAck(msg.MsgID)
		log.Printf("[Node] Failed to connect to service %s (%s): %v", service.Name, serviceAddr, err)
		return nil
	}

	// Create bridge
	bridge := &Bridge{
		ID:       bridgeID,
		Service:  *service,
		Conn:     svcConn,
		StopChan: make(chan struct{}),
	}

	nc.bridgeMu.Lock()
	nc.bridges[bridgeID] = bridge
	nc.bridgeMu.Unlock()

	// Send ACK
	if err := nc.sendAck(msg.MsgID); err != nil {
		bridge.Close()
		delete(nc.bridges, bridgeID)
		return fmt.Errorf("send ack: %w", err)
	}

	// Start bidirectional forwarding
	go nc.forwardServiceToRelay(bridge)

	log.Printf("[Node] Bridge %s opened: %s -> %s:%d", bridgeID, service.Name, service.Addr, service.Port)

	return nil
}

// handleCloseBridge handles CLOSE_BRIDGE requests from the relay
func (nc *NodeClient) handleCloseBridge(bridgeID string) error {
	nc.bridgeMu.Lock()
	bridge, exists := nc.bridges[bridgeID]
	if exists {
		delete(nc.bridges, bridgeID)
	}
	nc.bridgeMu.Unlock()

	if exists {
		log.Printf("[Node] Bridge %s closed: %s", bridgeID, bridge.Service.Name)
		bridge.Close()
	}

	return nil
}

// handleData handles DATA messages from the relay (to forward to service)
func (nc *NodeClient) handleData(msg *Message) error {
	data := msg.Data

	nc.bridgeMu.RLock()
	bridge, exists := nc.bridges[data.BridgeID]
	nc.bridgeMu.RUnlock()

	if !exists {
		return fmt.Errorf("data for unknown bridge: %s", data.BridgeID)
	}

	// Forward payload to service
	_, err := bridge.Conn.Write(data.Payload)
	if err != nil {
		return fmt.Errorf("write to service: %w", err)
	}

	return nil
}

// forwardServiceToRelay reads from service and sends to relay as DataMsg
func (nc *NodeClient) forwardServiceToRelay(bridge *Bridge) {
	buf := make([]byte, 4096)
	for {
		select {
		case <-bridge.StopChan:
			return
		case <-nc.shutdown:
			return
		default:
		}

		n, err := bridge.Conn.Read(buf)
		if err != nil {
			if err == io.EOF {
				log.Printf("[Node] Bridge %s disconnected: %s (EOF)", bridge.ID, bridge.Service.Name)
			} else {
				log.Printf("[Node] Bridge %s disconnected: %s (%v)", bridge.ID, bridge.Service.Name, err)
			}
			return
		}

		if n > 0 {
			// Store for testing
			nc.dataMu.Lock()
			nc.DataReceived[bridge.ID] = append(nc.DataReceived[bridge.ID], buf[:n]...)
			nc.dataMu.Unlock()

			msgID := uuid.New().String()
			msg := NewDataMsg(msgID, bridge.ID, buf[:n])

			if err := nc.conn.WriteMessage(msg); err != nil {
				log.Printf("[Node] Bridge %s: write to relay error: %v", bridge.ID, err)
				return
			}
		}
	}
}

// sendAck sends an ACK message to the relay
func (nc *NodeClient) sendAck(ackMsgID string) error {
	msgID := uuid.New().String()
	msg := NewAckMsg(msgID, ackMsgID)
	return nc.conn.WriteMessage(msg)
}

// Close shuts down the node client
func (nc *NodeClient) Close() {
	nc.closeMu.Lock()
	defer nc.closeMu.Unlock()

	if nc.closed {
		return
	}
	nc.closed = true

	close(nc.shutdown)

	// Close all bridges
	nc.bridgeMu.Lock()
	for _, bridge := range nc.bridges {
		bridge.Close()
	}
	nc.bridges = make(map[string]*Bridge)
	nc.bridgeMu.Unlock()

	// Close relay connection
	if nc.conn != nil {
		nc.conn.Close()
	}
}

// pingLoop sends periodic ping messages to keep the WebSocket connection alive
func (nc *NodeClient) pingLoop(wsConn *WebSocketConn) {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-nc.shutdown:
			return
		case <-ticker.C:
			deadline := time.Now().Add(5 * time.Second)
			if err := wsConn.WriteControl(websocket.PingMessage, []byte{}, deadline); err != nil {
				log.Printf("[Node] Ping failed: %v", err)
				nc.Close()
				return
			}
		}
	}
}

// validateRelayAddr validates that the relay address is a proper WebSocket URL
func validateRelayAddr(addr string) error {
	if !strings.HasPrefix(addr, "ws://") && !strings.HasPrefix(addr, "wss://") {
		return fmt.Errorf("relay_addr must be a WebSocket URL (ws:// or wss://), got: %s\nExample: ws://localhost:9020/node/connect", addr)
	}
	if !strings.Contains(addr, "/node/connect") {
		return fmt.Errorf("relay_addr must include /node/connect path, got: %s\nExample: ws://localhost:9020/node/connect", addr)
	}
	return nil
}

// GetReceivedData returns data received for a specific bridge (for testing)
func (nc *NodeClient) GetReceivedData(bridgeID string) []byte {
	nc.dataMu.Lock()
	defer nc.dataMu.Unlock()
	return nc.DataReceived[bridgeID]
}

// Close closes the bridge and its connection
func (b *Bridge) Close() {
	close(b.StopChan)
	if b.Conn != nil {
		b.Conn.Close()
	}
}
